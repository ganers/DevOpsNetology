* (1) Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
    #### Ответ:
    ```
      chdir("/tmp")
      P.s. Где в выводе strace я могу увидеть что результат выводится в поток 2 (stderr)?
    ```
  <br>
* (2) Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
      
      vagrant@netology1:~$ file /dev/tty
      /dev/tty: character special (5/0)
      vagrant@netology1:~$ file /dev/sda
      /dev/sda: block special (8/0)
      vagrant@netology1:~$ file /bin/bash
      /bin/bash: ELF 64-bit LSB shared object, x86-64
  Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
    #### Ответ:
    ```
      Не совсем понял как понять из вывода strace что это именно файл базы!!! Сделал предположение только из того, что этот файл открывается один из самых последних и видел попытки найти егог по другим каталогам.
      /usr/share/misc/magic.mgc 
    ```
  <br>
* (3) Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
    #### Ответ:
    ```
      Если я правильно понял задачу то нашел такой вариант решения:
      Через lsof находим информацию об удаленном файле, через ls -l в /proc/<pid>/fd/<file> узнаем его дескриптор,
      дальше перенаправляем /dev/null в дескриптор файла. cat /dev/null > /proc/<pid>/fd/<fd>.
      
      P.s. Только не совсем понял логиу 'cat /dev/null >'. Объясните пожалуйста как это правильно понимать!?
    ```
  <br>
* (4) Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
    #### Ответ:
    ```
      Нет, зомби процесс это всего лишь запись в таблице процессов хранящая только статус завершения.
    ```
  <br>
* (5) В iovisor BCC есть утилита opensnoop:

      root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
      /usr/sbin/opensnoop-bpfcc
  На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.
    #### Ответ:
    ```
      Непонял что тут надо сделать!!! Установил bpfcc-tools, запустил strace opensnoop-bpfcc - там куча файлов в 'openat('. 
    ```
  <br>
* (6) Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
    #### Ответ:
    ```
      Системный вызов также называется uname.
      Part of the utsname information is also accessible via  /proc/sys/kernel/{ostype,  hostname, osrelease, version, domainname}.
    ```
  <br>
* (7) Чем отличается последовательность команд через ; и через && в bash? Например:
      
      root@netology1:~# test -d /tmp/some_dir; echo Hi
      Hi
      root@netology1:~# test -d /tmp/some_dir && echo Hi
      root@netology1:~#
  Есть ли смысл использовать в bash &&, если применить set -e?
    #### Ответ:
    ```
      ; - используется для разделения команд, выполнятся будут все команды из списка.
      && - следующая команда будет выполнятся только если преидущая выполнилась успешно (возвращает статусь 0).
      По поводу использования && если применить set -e, в приведеном примере && не будет работать как надо. Только я не совсем понял из мануала почему так!!!
      set -e должна прекращать работу если статус команды не 0 (не успешна) - test -d /tmp/some_dir статус будет не 0, почему так? 
    ```
  <br>
* (8) Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
    #### Ответ:
    ```
      
    ```
  <br>
* (9) Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
    #### Ответ:
    ```
      Наиболее часто встречающиеся статусы процессов S(в ожидании) и I(бездействует).
      Дополнительные символы к основному:
               <    high-priority (not nice to other users)
               N    low-priority (nice to other users)
               L    has pages locked into memory (for real-time and custom IO)
               s    is a session leader
               l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
               +    is in the foreground process group
  
      P.s. про эти дополнительные буквы идет реч???
    ```
  <br>